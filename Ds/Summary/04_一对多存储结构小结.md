# 04_一对多存储结构小结

## 二叉树概述

![二叉树](./images/二叉树.svg)

二叉树由一个**根节点**加上两个**互不相交**的**左右子树**构成，或者是一个没有结点的空树。

* 每个结点最多有两个子结点。
* 左子树和右子树不可互换，是有序的。

例如，结点A 为根节点，以结点B 为根节点的子树为左子树，以结点C为根节点的子树称为右子树。

>  二叉树的5种基本形态

* 空树
* 只含根节点
* 右子树为空
* 左子树为空
* 左右子树都不为空

> 满二叉树和完全二叉树

* 满二叉树 -->> **每一层都充满结点**

  * 叶子结点只能在最后一层
  * 非叶子结点的度一定是2
  * 在同样深度的二叉树中
  * 满二叉树的结点数最多（因为每个结点都有两个孩子）；
    * 拥有的叶子结点的个数也最多（因为每个结点都有两个孩子，一直到最后一层叶子结点，必然是最多的）；
  * 在相同结点数的树中，满二叉树的深度最小。

  ![二叉树](./images/二叉树.svg)

* 完全二叉树 -->> 最后一层结点可以不满，但必须**集中在左边**。

  * 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。
  * 某结点的度如果为1，则它只有**左孩子**。
  * 叶子结点只能出现在**最后两层**。
  * 相同结点的树中，完全二叉树的深度最小。
  
  ![完全二叉树](./images/完全二叉树.svg)

> 二叉树的性质

* 性质1

  第 a 层的节点数，至多为 **2^a-1^​**

* 性质2

  深度为 k 的二叉树，节点数至多为 **2^k^ - 1** 个

* 性质3

  若 n~k~ 代表度（孩子个数）为 k 的结点个数，则 n~0~ = n~2~ + 1（**叶子节点数 = 2度结点树 + 1**）

* 性质4

  具有 n 个结点的**完全二叉树**，深度 **k = log~2~n + 1**

* 性质5

  将具有 **n个结点**的**完全二叉树**按照一维数组方式从左到右，从上层到子层，从0开始编号，编号为j的结点

  * 根节点编号为0

  * 左子树根节点为 2j + 1，右子树为 2(j + 1)

  * 判断有子树（即是判断是否有左子树）

    2j + 1 ≤ n - 1，推导出 **2j + 1 < n**

  * 判断左右子树都有（即是判断有右子树）
  
    2(j + 1) ≤ n - 1


> 二叉树的存储方式

* 顺序存储

  将二叉树转换为**完全二叉树**进行存储。

  * 顺序存储的方式缺陷
    * 转换为完全二叉树，浪费空间

    * 新一层数据的插入不方便。

    * 删除非叶子节点不方便。

  ![二叉树的顺序存储](./images/二叉树的顺序存储.jpg)

* 链式存储方式

  ![二叉树的链式存储结构](./images/二叉树的链式存储.jpg)

## 二叉树的链式表示

* 由于顺序存储方式劣势比较明显，平常用到的表示方式都是链式表示。

> 二叉树的存储结构

* 采用链式存储的方式，结点只存单个元素值，节点之间通过指针联系，维持集合的关系。

* 这里定义了指向父节点的指针，方便从子节点找父节点。

  ```c
  // 定义返回状态及返回码
  #define Status int
  #define OK 1
  #define ERROR 0
  // 定义存储的元素类型
  #define ElementType int
  
  // 二叉树结点结构定义
  typedef struct BinaryTreeNode
  {
  	// 数据域
  	ElementType data;
  	// 指向左孩子的指针
  	BinaryTreeNode* left;
  	// 指向右孩子的指针
  	BinaryTreeNode* right;
  	// 指向父节点的指针
  	BinaryTreeNode* parent;
  }BTNode, *BinaryTree;
  ```

> 二叉树的常用操作

* 初始化

  * 拿到一个指向根结点的指针，即可确定一个二叉树

    ```c
    /* 01_二叉树——初始化*/
    Status initBiTree_L(BinaryTree& biTree)
    {
        biTree = NULL;
        return OK;
    }
    ```

* 销毁

  * 销毁一个二叉树结点是通过指向该结点的指针进行的。

    * 如果结点为空，则不需要进行操作

    * 如果结点不为空，则需要先删除左右孩子结点，再删除该结点

    ```c
    /* 02_二叉树——销毁*/
    Status destroyBiTree_L(BinaryTree& biTree)
    {
        // 如果结点不为空
        if (biTree)
        {
            biTree->parent = NULL;
            // 先删除左右子树
            if (destroyBiTree_L(biTree->left) && destroyBiTree_L(biTree->right))
            {
                return OK;
            }
            // 再删除该结点
            delete biTree;
        }
    	return OK;
    }
    ```
  
* 判空（是否为空树）

  * 即是判断根节点是否为空

    ```c
    /* 03_二叉树——判空*/
    Status emptyBiTree_L(BinaryTree biTree)
    {
        return biTree == NULL ? OK : ERROR;
    }
    ```

* 求深度

  * 利用树的递归，采用累加的方式求得。
  
  * 如果一个结点不为空，则该层的深度为1
  
  * 一个结点的深度，即是其左结点深度，与右节点的深度的较大者，加上本层的深度1。
  
    ```c
    /* 04_二叉树——深度*/
    int treeDepth_L(BinaryTree biTree)
    {
        // 该结点为空，则该层深度为0
        if (!biTree)
        {
            return 0;
        }
        // 否则，该层深度有1，要向上累加
        else
        {
            int leftDepth = treeDepth_L(biTree->left);
            int rightDepth = treeDepth_L(biTree->right);
            // 左右子树的深度，加上本层的深度1，即是该结点的深度
            return 1 + max(leftDepth, rightDepth);
        }
    }
    
    /*返回两个数较大的一个*/
    int max(int a, int b)
    {
        return a > b ? a : b;
    }
    ```
  
* 是否叶子结点

  * 左右孩子都不存在，即是叶子结点

    ```c
    /* 05_二叉树——是否是叶子结点*/
    Status leafBiNode_L(BinaryTree biTree)
    {
        // 左右孩子都不存在，即为叶子结点
        return (biTree->left == NULL && biTree->right == NULL) ? OK : ERROR;
    }
    ```

* 是否根结点

  * 父节点为空

    ```c
    /* 06_二叉树——是否根节点*/
    Status rootBiNode_L(BinaryTree biTree)
    {
        return biTree->parent == NULL ? OK : ERROR;
    }
    ```

* 求父节点

  * 如果当前结点为空或当前结点是根节点，返回空。
  
  * 设置当前结点所存的父节点信息，并返回。
  
    ```c
    /* 06_二叉树——求父节点*/
    Status parentBiNode_L(BinaryTree current, BinaryTree& parent)
    {
        // 如果当前结点为空，或当前结点为根节点
        if (emptyBiTree_L(current) || rootBiNode_L(current))
        {
            parent = NULL;
            return ERROR;
        }
        parent = current->parent;
        return OK;
    }
    ```

* 